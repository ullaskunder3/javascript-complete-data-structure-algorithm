1. Array.prototype.forEach(): Executes a provided function once for each array element.
2. Array.prototype.map(): Creates a new array by calling a provided function on each element of the array.
3. Array.prototype.filter(): Creates a new array with elements that pass a certain condition specified by a provided function.
4. Array.prototype.reduce(): Applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value.
5. Array.prototype.find(): Returns the first element in the array that satisfies a provided testing function.
6. Array.prototype.findIndex(): Returns the index of the first element in the array that satisfies a provided testing function.
7. Array.prototype.some(): Checks if at least one element in the array satisfies a provided testing function.
8. Array.prototype.every(): Checks if all elements in the array satisfy a provided testing function.
9. Array.prototype.includes(): Determines whether an array includes a certain element, returning true or false.
10. Array.prototype.sort(): Sorts the elements of an array in place and returns the sorted array.
11. Array.prototype.reverse(): Reverses the order of elements in an array in place.
12. String.prototype.split(): Splits a string into an array of substrings based on a specified separator.
13. String.prototype.includes(): Determines whether a string contains another string or character, returning true or false.
14. String.prototype.trim(): Removes whitespace from both ends of a string.
15. Set and Map: ES6 introduces Set and Map data structures that can be handy for solving various DSA problems.

Data Structures:
1. Arrays: Understand indexing, access, insertion, and deletion operations.
2. Linked Lists: Know the difference between singly linked lists and doubly linked lists. Understand operations like insertion, deletion, and traversal.
3. Stacks: Understand the Last-In-First-Out (LIFO) principle and operations like push and pop.
4. Queues: Understand the First-In-First-Out (FIFO) principle and operations like enqueue and dequeue.
5. Hash Tables: Understand key-value pairs, hash functions, and collision resolution techniques.
6. Trees: Understand binary trees, binary search trees, and tree traversal algorithms (e.g., inorder, preorder, postorder).
7. Heaps: Understand min heaps and max heaps, as well as operations like insertion, deletion, and heapify.
8. Graphs: Understand graph representation (e.g., adjacency matrix, adjacency list) and traversal algorithms (e.g., BFS, DFS).

Algorithms:
1. Searching: Understand linear search, binary search, and their time complexities.
2. Sorting: Understand various sorting algorithms like bubble sort, selection sort, insertion sort, merge sort, quicksort, and their time complexities.
3. Recursion: Understand the concept of recursion and its implementation.
4. Dynamic Programming: Understand the concept of breaking down complex problems into smaller subproblems and solving them efficiently.
5. Graph Algorithms: Understand algorithms like breadth-first search (BFS), depth-first search (DFS), Dijkstra's algorithm, and others.

Other Concepts:
1. Time Complexity: Understand Big O notation and analyze the time complexity of algorithms.
2. Space Complexity: Analyze the space complexity of algorithms and understand concepts like auxiliary space.
3. Divide and Conquer: Understand the concept of dividing a problem into smaller subproblems and combining the results.
4. Greedy Algorithms: Understand the concept of making locally optimal choices to find a global optimum.
5. Backtracking: Understand the concept of exploring all possible solutions by trying different paths and backtracking when necessary.